# 2-3 进程同步和互斥

## 1. 概念

`进程同步`：并发性带来了异步性，有时需要通过进程同步解决这种异步问题。有的进程之间需要相互配合地完成工作，各进程地工作推进需要遵循一定的先后顺序。

`临界资源`：一个时间段内只允许一个进程使用的资源称为临界资源。对临界资源的访问必须互斥进行，亦称为间接制约关系。

`进程互斥`：当一个进程访问某临界资源时，另一个想要访问该临界资源的进程必须等待。当前访问临界资源的进程访问结束，释放资源之后，另一个进程才能去访问临界资源。

对临界资源的互斥访问，可在逻辑上分为如下四个部分：

![](./2-1.png)

注意：
1. `临界区（临界段）`：`进程中访问临界资源的代码段`
2. `进入区`和`退出区`是`负责实现互斥的代码段`。

为了`实现对临界资源的互斥访问`，同时`保证系统整体性能`，需要`遵循以下原则`：
1. `空闲让进`。临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区。
2. `忙则等待`。当已有进程进入临界区时，其他试图进入临界区的进程必须等待。
3. `有限等待`。对请求访问的进程，应保证能在有限时间进入临界区（保证不会饥饿）。
4. `让权等待`：当进程不能进入临界区时，应立即释放处理机，防止进程忙等待。

## 2. 实现互斥的软件实现方式

1. 单标志法
2. 双标志先检查
3. 双标志后检查
4. Peterson算法

### 2.1 单标志法

`算法思想`：两个进程在`访问完临界区后`会把使用临界区的权限转交给另一个进程。也就是说`每个进程进入临界区的权限只能被另一个进程赋予`。

![](./2-2.png)

turn的初值为0，即刚开始只允许0号进程进入临界区。

若P1先上处理机运行，则会一直卡在⑤。直到P1的时间片用完，发生调度，切换P0上处理机运行。代码 ① 不会卡住 P0，P0 可以正常访问临界区，在 P0 访问临界区期间即时切换回 P1，P1依然会卡在 ⑤。只有 P0 在退出区将 turn 改为 1 后，P1才能进入临界区。

缺点：只能按 P0 -> P1 -> P0 -> P1 -> ……这样轮流访问。如果此时允许进入临界区的进程是 P0，而 P0 一直不访问临界区，那么虽然此时临界区空闲，但是并不允许 P1 访问。单标志法存在的主要问题是：`违背“空闲让进”原则`。

### 2.2 双标志先检查法

`算法思想`：设置一个布尔型数组flag[]，数组中各个元素用来标记各进程进入临界区的意愿。比如 “flag[0] = ture”意味着 0 号进程 P0 现在想要进入临界区。每个进程在进入临界区之前先检查当前有 没有别的进程想进入临界区，如果没有，则把自身对应的标志 flag[i] 设为 true，之后开始访问临界区。

![](./2-3.png)

`缺点`：若按照 ①⑤②⑥③⑦….的顺序执行，P0 和 P1 将会同时访问临界区。
因此，双标志先检查法的主要问题是：违反“忙则等待”原则。原因在于，进入区的“检查”和“上锁” 两个处理不是一气呵成的。“检查”后，“上锁”前可能发
生进程切换。

### 2.3 双标志后检查法

`算法思想`：双标志先检查法的改版。前一个算法的问题是先“检查”后“上锁”，但是这两个操作又无法一气呵成，因此导致了两个进程同时进入临界区的问题。因此，人们又想到先“上锁”后“检查”的方法，来避免上述问题。

![](./2-4.png)

`缺点`：若按照 ①⑤②⑥….的顺序执行，P0 和 P1 将都无法进入临界区。因此，双标志后检查法虽然解决了`“忙则等待”`的问题，但是又违背了`“空闲让进”`和`“有限等待”`原则，会因各进程都长期无法访问临界资源而产生“饥饿”现象。两个进程都争着想进入临界区，但是谁也不让谁，最后谁都无法进入临界区。

### 2.4 Peterson算法

`算法思想`：结合双标志法、单标志法的思想。如果双方都争着想进入临界区，那可以让进程尝试“孔融让梨”（谦让）。

![](./2-5.png)

`缺点`：Peterson 算法用软件方法解决了进程互斥问题，遵循了`空闲让进、忙则等待、有限等待`三个原则，但是依然未遵循`让权等待`的原则。

## 3. 进程互斥的硬件实现方法

1. 中断屏蔽
2. TestAndSet(TS指令/TSL指令)
3. Swap指令(XCHG指令)

### 3.1 中断屏蔽

利用“开/关中断指令”实现。

![](./2-6.png)

- 优点：简单、高效
- 缺点：不适用于多处理机；只适用于操作系统内核进程，不适用于用户进程（因为开/关中断指令只能运行在内核态，这组指令如果能让用户随意使用会很危险）。

### 3.2 TestAndSet指令

TSL 指令是用硬件实现的，执行的过程不允许被中断，只能一气呵成。

![](./2-7.png)

若刚开始 lock 是 false，则 TSL 返回的 old 值为 false，while 循环条件不满足，直接跳过循环，进入临界区。若刚开始 lock 是 true，则执行 TLS 后 old 返回的值为 true，while 循环条件满足，会一直循环，直到当前访问临界区的进程在退出区进行“解锁”。

相比软件实现方法，TSL 指令把“上锁”和“检查”操作用硬件的方式变成了一气呵成的原子操作。

- 优点：实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞；适用于多处理机环境
- 缺点：不满足“让权等待”原则，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从而导致“忙等”。

### 3.3 Swap指令

Exchange指令，XCHG指令。

Swap指令是用硬件实现的，执行的过程不允许被中断，只能一气呵成。

![](./2-8.png)

逻辑上来看 Swap 和 TSL 并无太大区别，都是先记录下此时临界区是否已经被上锁（记录在 old 变量上），再将上锁标记 lock 设置为 true，最后检查 old，如果 old 为 false 则说明之前没有别的进程对临界区上锁，则可跳出循环，进入临界区。

- 优点：实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞；适用于多处理机环境
- 缺点：不满足“让权等待”原则，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从而导致“忙等”。

# 4. 信号量

`信号量`其实就是一个变量（可以是一个整数，也可以是复杂的记录型变量），可以用一个信号量来表示`系统中某种资源的数量`。

`一对原语`：`wait(S)`原语和`signal(S)`原语，可以把原语理解为我们自己写的函数，函数名为wait和signal，括号里的`信号量S`其实就是函数调用时传入的一个参数。

wait、signal原语常简称为`P、V操作`（荷兰语proberen和verhogen）。因此，做题的时候常把wait(S)、signal(S)两个操作分别写为`P(S)、V(S)`。

## 4.1 整数型信号量

用一个`整数型的变量`作为信号量，用来`表示系统中某种资源的数量`。

![](./2-9.png)

`与普通整数变量的区别`：对信号量的操作只有三种，初始化、P操作、V操作。

wait和signal是一对原语，保证了`“检查”和“上锁”一气呵成`，避免了并发、异步导致的问题。

存在的问题：不满足`让权等待`，会发生`忙等`。

## 4.2 记录型信号量

![](./2-10.png)

`初始化`：S.value 的初值表示系统中某种资源的数目。

P操作：进程请求一个单位的该类资源，因此需要执行 S.value--，表示资源数减1，当S.value < 0 时表示该类资源已分配完毕，因此进程应调 用 block 原语进行自我阻塞（当前运行的进程从运行态->阻塞态），主动放弃处理机，并插入该类资源的等待队列 S.L 中。可见，该机制遵循了“让权等待”原则，
不会出现“忙等”现象。

V操作：进程释放一个单位的该类资源，因此需要执行 S.value++，表示资源数加1，若加1后仍是 S.value <= 0，表示依然有进程在等待该类资源，因此应调用 wakeup 原语唤醒等待队列中的第一个进程（被唤醒进程从阻塞态->就绪态）

`优点`：`解决了忙等待问题`。

## 5. 使用信号量处理同步互斥问题

### 5.1 使用信号量处理互斥问题

1. 分析并发进程的关键活动，划定临界区
2. `设置互斥信号量 mutex，初值为1`
3. `在进入区 P(mutex)——申请资源`
4. `在退出区 V(mutex)——释放资源`

注意：对`不同的临界资源`需要`设置不同的互斥信号量`。`P、V操作必须成对出现`。缺少P(mutex) 就不能保证临界资源的互斥访问。缺少 V(mutex) 会导致资源永不被释放，等待进程永不被唤醒。

![](./2-11.png)

### 5.2 使用信号量实现进程同步

1. 分析什么地方需要实现“同步关系”，即必须保证“一前一后”执行的两个操作（或两句代码）
2. 设置同步信号量 S, 初始为 0
3. 在“前操作”之后执行 V(S)
4. 在“后操作”之前执行 P(S)

注意：信号量S代表“某种资源”，刚开始是没有这种资源的。P2需要使用这种资源，而又只能由P1产生这种资源。

![](./2-12.png)

若先执行到 V(S) 操作，则 S++ 后 S=1。之后当执行到 P(S) 操作时，由于 S=1，表示有可用资源，会执行 S--，S 的值变回 0，P2 进程不会执行 block 原语，而是继续往下执行代码4。

若先执行到 P(S) 操作，由于 S=0，S-- 后 S=-1，表示此时没有可用资源，因此P操作中会执行 block 原语，主动请求阻塞。之后当执行完代码2，继而执行 V(S) 操作， S++，使 S 变回 0，由于此时有进程在该信号量对应的阻塞队列中，因此会在 V 操作中执行 wakeup 原语，唤醒 P2 进程。这样 P2 就可以继续执行 代码4 了。

### 5.3 信号量机制实现前驱关系

其实每一对前驱关系都是一个进程同步问题（需要保证一前一后的操作）。因此，
1. 要为每一对前驱关系各设置一个同步信号量
2. 在“前操作”之后对相应的同步信号量执行 V 操作
3. 在“后操作”之前对相应的同步信号量执行 P 操作

![](./2-13.png)

![](./2-14.png)

## 6. 常见同步互斥模型

常见的同步互斥模型包括：
1. 生产者消费者问题
2. 多生产者——多消费者问题
3. 吸烟者问题
4. 读者——写者问题
5. 哲学家进餐问题

`PV操作题目分析步骤`：
1. `关系分析`。找出题目中描述的各个进程，分析它们之间的同步、互斥关系。
2. `整理思路`。根据各进程的操作流程确定P、V操作的大致顺序。
3. `设置信号量`。并根据题目条件确定信号量初值。（互斥信号量初值一般为1，同步信号量的初始值要看对应资源的初始值是多少

注意：
1. `分析问题要基于状态转换，而不是具体的操作`。
2. `实现互斥的P操作一定要在实现同步的P操作之后。V操作顺序可以交换。`
3. 当缓冲区大小为1时，有些时候可以省略互斥信号量。

### 6.1 生产者消费者问题

`问题描述`：系统中有一组生产者进程和一组消费者进程，生产者进程每次生产一个产品放入缓冲区，消费者进程每次从缓冲区中取出一个产品并使用。生产者、消费者共享一个初始为空、大小为n的缓冲区。
1. 只有缓冲区没满时，生产者才能把产品放入缓冲区，否则必须等待。
2. 只有缓冲区不空时，消费者才能从中取出产品，否则必须等待。
3. 缓冲区是临界资源，各进程必须互斥地访问。

`问题分析`：
1. 同步关系
   1. 缓冲区中有空位-----------> 生产者生产数据 - empty
   2. 缓冲区中有数据-----------> 消费者消费数据 - full
2. 互斥关系. 
   1. 缓冲区是临界资源，各进程互斥访问 - mutex

因此有3个信号量：
1. empty = n - 同步信号量，表示空位的数量
2. full = 0 - 同步信号量，表示数据的数量
3. mutex = 1 - 互斥信号量

`代码`：

![](./2-15.png)

注意，不可以写成如下形式，会造成死锁：

![](./2-16.png)

若empty = 0，则执行②操作后，会被阻塞，而此时mutex=0，进程切换到consumer时， ③操作无法执行，也就是消费者无法消费数据，因此造成了死锁。

### 6.2 多生产者——多消费者问题

`问题描述`：
- 桌子上有一只盘子，`每次只能向其中放入一个水果`。
- `爸爸专向盘子中放苹果`，
- `妈妈专向盘子中放橘子`，
- `儿子专等着吃`盘子中的`橘子`，
- `女儿专等着吃`盘子中的`苹果`。
- `只有盘子空时`，`爸爸或妈妈才可向盘子中放一个水果`。
- `仅当盘子中有自己需要的水果时，儿子或女儿可以从盘子中取出水果`。

`问题分析`：
1. 同步关系
   1. 盘子里有一个苹果----->女儿吃苹果--apple
   2. 盘子里有一个橘子----->儿子吃橘子--oringe
   3. 盘子为空------------->父母可以放橘子和苹果 - plate
2. 互斥关系
   1. 对盘子的访问只能互斥进行 - mutex

因此有4个信号量：
1. apple = 0 - 表示盘子里的苹果数
2. oringe = 0 - 表示盘子里的橘子数
3. plate = 0 - 盘子中的水果数
4. mutex = 1 - 互斥访问的变量

`代码`：

![](./2-17.png)

![](./2-18.png)

本题中，互斥信号量可以省下来。当缓冲区大小为1时，有些时候可以省略mutex。

### 6.3 吸烟者问题

`问题描述`：
- 假设一个系统有三个抽烟者进程和一个供应者进程。
- 每个抽烟者不停地卷烟并抽掉它，但是要卷起并抽掉一支烟，抽烟者需要有三种材料：烟草、纸和胶水。三个抽烟者中，第一个拥有烟草、第二个拥有纸、第三个拥有胶水。
- 供应者进程无限地提供三种材料，供应者每次将两种材料放桌子上，拥有剩下那种材料的抽烟者卷一根烟并抽掉它，
- 并给供应者进程一个信号告诉完成了，供应者就会放另外两种材料再桌上，这个过程一直重复
- （让三个抽烟者轮流地抽烟）

`问题分析`：
1. 同步关系：
   1. 桌子上有烟草、胶水 ----> 抽烟者1卷烟
   2. 桌子上有烟草、纸 ----> 抽烟者2卷烟
   3. 桌子上有胶水、纸 ----> 抽烟者3卷烟
   4. 抽烟者抽完烟 --------> 供应者放入材料
2. 互斥关系
   1. 对桌子需要互斥访问

因此需要信号量；
1. offer1 = 0 - 材料组合1的份数
2. offer2 = 0 - 材料组合2的份数
3. offer3 = 0 - 材料组合3的份数
4. finish  = 0 - 桌子上材料的份数
5. i  = 0 - 实现顺序抽烟

![](./2-19.png)

### 6.4 读者——写者问题

`问题描述`：
有读者和写者两组并发进程，共享一个文件，当两个或两个以上的读进程同时访问共享数据时不会产生副作用，但若某个写进程和其他进程（读进程或写进程）同时访问共享数据时则可能导致数据不一致的错误。因此要求：
1. 允许多个读者可以同时对文件执行读操作；
2. 只允许一个写者往文件中写信息；
3. 任一写者在完成写操作之前不允许其他读者或写者工作；
4. 写者执行写操作前，应让已有的读者和写者全部退出。

`问题分析`：

两个进程：
1. 读进程
2. 写进程

互斥关系：
1. 写进程-写进程
2. 读进程-写进程

该问题不存在同步关系。因此只需要一个信号量mutex。

`代码`：

第一版本：
![](./2-20.png)

第二版本：
![](./2-21.png)

简单解释w信号量：第二版本达到了读写公平的目的，第一个版本没有。则
1. 需要记录读写的顺序，而记录型信号量中有一个队列，因此w的一个作用是作为一个队列。
2. 需要在写操作后拦住所有的读操作。如果存在读操作正在处理，写操作会被rw阻塞，而其他的操作都会被w阻塞。

### 6.5 哲学家进餐问题

`问题描述`：一张圆桌上坐着5名哲学家，每两个哲学家之间的桌上摆一根筷子，桌子的中间是一碗米饭。哲学家们倾注毕生的精力用于思考和进餐，哲学家在思考时，并不影响他人。只有当哲学家饥饿时，才试图拿起左、右两根筷子（一根一根地拿起）。如果筷子已在他人手上，则需等待。饥饿的哲学家只有同时拿起两根筷子才可以开始进餐，当进餐完毕后，放下筷子继续思考。

![](./2-22.png)

`关系分析`：系统中有5个哲学家进程，5位哲学家与左右邻居对其中间筷子的访问是互斥关系。

`整理思路`：哲学家进餐问题的精髓是如何避免临界资源分配不当造成的死锁现象。

`信号量设置`：定义互斥信号量数组chopstick[5]={1,1,1,1,1} 用于实现对5个筷子的互斥访问。并对哲学家按0~4编号，哲学家 i 左边的筷子编号为 i，右边的筷子编号为 (i+1)%5。

如何防止死锁发生？
1. 可以对哲学家进程施加一些限制条件，比如最多允许四个哲学家同时进餐。这样可以保证至少有一个哲学家是可以拿到左右两只筷子的。
2. 要求奇数号哲学家先拿左边的筷子，然后再拿右边的筷子，而偶数号哲学家刚好相反。用这种方法可以保证如果相邻的两个奇偶号哲学家都想吃饭，那么只会有其中一个可以拿起第一只筷子，另一个会直接阻塞。这就避免了占有一支后再等待另一只的情况。
3. 仅当一个哲学家左右两支筷子都可用时才允许他抓起筷子。
   ![](./2-23.png)

## 7. 管程

引入管程的原因：`信号量机制存在一些固有的问题：编写程序困难、易出错。`

管程是一种特殊的软件模块，有这些部分组成：
1. 局部于管程的共享数据结构说明；
2. 对该数据结构进行操作的一组过程；
3. 对局部于管程的共享数据设置初始值的语句；
4. 管程有一个名字。

管程的基本特征：
1. 局部于管程的数据只能被局部于管程的过程所访问；
2. 一个进程只有通过调用管程内的过程才能进入管程访问共享数据；
3. 每次仅允许一个进程在管程内执行某个内部过程。
4. 各进程需要互斥地访问共享缓冲区。注意：这种互斥特性是由编译器负责实现的
5. 可在管程中设置条件变量及等待/唤醒操作以解决同步问题。