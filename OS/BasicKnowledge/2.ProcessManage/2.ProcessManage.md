# 2. 进程管理基础知识

## 2.1 进程的概念、组成及其特征

### 2.1.1 进程的概念

`程序`：存放在磁盘中的可执行文件

`进程`：程序的一次执行过程。

`程序 vs 进程`：程序是静态的，进程是动态的。同一程序多次执行会产生多个进程。

### 2.1.1 进程的组成

进程(进程实体,进程映像)由以下三部分组成：
1. 程序段：程序的代码（指令序列）
2. 数据段：运行过程中的产生的各种数据（如：程序中定义的变量）
3. PCB（Process Control Block）：进程控制块
    1. 进程描述信息：进程标识符PID、用户标识符UID
    2. 进程控制和管理信息
        - CPU/磁盘/网络流量使用情况统计...
        - 进程当前状态:就绪态/阻塞态/运行态... 
    3. 资源分配清单
        - 文件
        - 内存区域
        - IO设备
    4. 处理机相关信息
        - 寄存器

`注意`:
1. `PCB`是给`操作系统`用的.`程序段\数据段`是`给进程自己用的`.
2. `进程`是进程实体的运行过程,是系统进行`资源分配`和`调度`的一个独立单位.
3. PCB是进程存在的唯一标志.
4. 一个进程被调度,就是指操作系统决定让这个进程在CPU上执行

### 2.1.2 进程的特点

1. 动态性(`进程的最基本特征`):进程是程序的一次执行过程,是动态地产生、变化、消亡的
2. 并发性:内存中有多个进程实体，各进程可并发执行
3. 独立性:`进程是能独立运行、独立获得资源、独立接受调度的基本单位`
4. 异步性(导致并发程序执行结果的不稳定性):`各进程按各自独立的、不可预知的速度向前推进，`操作系统要提供“进程同步机制”来解决异步问题
5. 结构性:每个进程都会配置一个PCB。结构上看，进程由程序段、数据段、PCB三部分组成。

## 2.2 进程的执行过程及其状态

### 2.2.1 进程是如何运行的？

![](./2-1.png)

一个程序开始运行前，需要创建进程对应的PCB、数据段、程序段，分配需要的资源。

### 2.2.2 进程的状态

1. 创建态：`进程正在被创建时`，它的状态是`“创建态”`，这个阶段操作系统会为进程`分配资源、初始化PCB`。
2. 就绪态：当进程创建完成之后，便进入`“就绪态”`，`处于就绪态的进程已经具备运行条件，但由于没有空闲CPU，就不能暂时运行。`
3. 阻塞态：因等待某一事件而暂时无法运行
4. 运行态：如果一个进程此时在CPU上运行，则这个进程处于`“运行态”`
5. 终止态：进程正在从系统中撤销，操作系统会回收进程拥有的资源，撤销PCB。

其中，`就绪态、阻塞态、运行态`为三种基本状态。

进程状态转换示意图：

![](./2-2.png)

- 创建态->就绪态：系统完成创建进程相关的工作。
- 就绪态->运行态：进程被调度
- 运行态->就绪态：时间片到，或CPU被其他高优先级的进程抢占
- 运行态->阻塞态：等待系统资源分配，或等待某事件发生（主动行为）
- 阻塞态->就绪态：资源分配到位，等待的事件发生（被动行为）
- 运行态->终止态：进程运行结束，或运行过程中遇到不可修复的错误。

### 2.2.3 进程的组织形式

链接方式：按照进程状态将PCB分为多个队列，操作系统持有指向各个队列的指针。

![](./2-3.png)

![](./2-4.png)

索引方式：根据进程状态的不同，建立几张索引表，操作系统持有指向哥哥索引表的指针。

![](./2-5.png)

## 2.4 进程控制

`进程控制`的主要功能是`对系统中的所有进程实施有效的管理`，它具有`创建新进程、撤销已有进程、实现进程状态转换`等功能。

`实现进程控制的方式`：用原语实现。原语是一种特殊的程序，它的`执行具有原子性`。也就是说，`这段程序的运行必须一气呵成，不可中断`。

简单解释为何进程控制要使用原语实现：

![](./2-6.png)

`原语的实现`：原语可以使用`“关中断指令”`和`“开中断指令”`这两个`特权指令`实现原子性。

`注意`：`开关中断，开关的不是中断的产生，而是中断的检测`。正常情况：CPU每执行完一条指令都会例行检查是否有中断信号需要处理，如果有，则暂停运行当前这段程序，转而执行相应的中断处理程序。详见[1.5部分的讲解](../1.Introduction/1.Introduction.md/##1.5)

常见的进程管理原语如下：

1. 进程创建
2. 进程终止
3. 进程阻塞
4. 进程唤醒
5. 进程切换

无论哪个进程控制原语，要做的无非三类事情：
1. 更新PCB中的信息（修改进程状态state，保存/回复运行环境）
2. 将PCB插入合适的队列
3. 分配/回收资源

![](./2-7.png)

### 2.4.1 进程创建

进程创建原语的执行过程：
1. 创建空白PCB
2. 为新进程分配所需资源
3. 初始化PCB
4. 将PCB插入到就绪队列----->创建态转化为就绪态

引起进程创建的事件：
1. 用户登录：分时系统中，用户登陆成功，系统会为其建立一个新的进程
2. 作业调度：多道批处理系统中，有新的作业放入内存时，会为其建立一个新的进程
3. 提供服务：用户向操作系统提出某些请求时，会建立一个新进程处理该请求
4. 应用请求：由用户进程主动请求创建一个子进程

### 2.4.2 进程终止

进程撤消原语的执行过程：
1. 从PCB集合中找到终止进程的PCB
2. 若进程正在运行，立即剥夺CPU，将CPU分配给其他进程
3. 终止其所有子进程
4. 将该进程拥有的所有资源归还给父进程或操作系统
5. 删除PCB

引起进程终止的事件：
1. 正常结束：进程自己请求终止（exit系统调用）
2. 异常结束：整数除以0，非法使用特权指令，然后被操作系统强行杀死
3. 外界干预：用户选择杀掉进程

### 2.4.3 进程的阻塞和唤醒

进程阻塞原语的执行过程：
1. 找到要阻塞的进程对应的PCB
2. 保护进程运行现场，将PCB状态信息设置为“阻塞态”，暂时停止进程运行
3. 将PCB插入相应事件的等待队列

引进进程阻塞的事件：
1. 需要等待系统分配某种资源
2. 需要等待相互核作的其他进程完成工作

进程唤醒原语的执行过程：
1. 在事件等待队列中找到PCB
2. 将PCB从等待队列移除，设置进程为就绪态
3. 将PCB插入就绪队列，等待被调度

引进进程唤醒的事件：等待的事件发生（因何事阻塞，就由何事唤醒）

注意：阻塞原语和唤醒原语必须成对使用。

### 2.4.4 进程的切换

进程切换原语的执行过程：
1. 将运行环境信息存入PCB
2. 将PCB移入相应队列
3. 选择另一个进程执行，并更新其PCB
4. 根据PCB恢复新进程所需的运行环境

引起进程切换的事件：
1. 当前进程时间片到
2. 有更高优先级的进程到达
3. 当前进程主动阻塞
4. 当前进程终止

## 2.5 进程通信（IPC）

进程间通信（IPC）是指两个进程之间产生数据交互。

进程是分配系统资源的单位（包括内存地址空间），因此各进程拥有的内存地址空间相互独立。

为了保证安全，一个进程不能直接访问另一个进程的地址空间。

进程通信一般包括如下三种实现方式：
1. 共享存储
2. 消息传递
3. 管道通信

### 2.5.1 共享存储

共享存储包括两种方式：

1. 基于数据结构的共享：例如共享空间内只放一个长度为10的数组。这种`共享方式速度慢、限制多`，是一种`低级通信方式`。
2. 基于存储区的共享：操作系统在内存中`划分出一块共享存储区`，`数据的形式、存放位置都由通信进程控制，而不是操作系统`。这种方式速度很快，是一种`高级通信方式`。

![](./2-8.png)

### 2.5.2 消息传递

进程间的数据交换以格式化的消息为单位。进程通过操作系统提供的“发送消息/接收消息”两个原语进行数据交换。

![](./2-9.png)

消息传递包括：
1. 直接通信方式：消息发送进程要指明接收进程的ID
2. 间接通信方式：通过“信箱”间接地通信，因此又称“信箱通信方式”。

#### 2.5.2.1 直接通信方式

![](./2-10.png)

![](./2-11.png)

![](./2-12.png)

#### 2.5.2.2 间接通信方式

间接通信方式以“信箱”作为中介实体进行消息传递。SOCKET套接字就是这种方式最好的例子。

![](./2-13.png)

![](./2-14.png)

![](./2-15.png)